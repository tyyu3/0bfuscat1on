# 0bfuscat1on

Программа демонстрирует несколько техник обфускации. Сама по себе она принимает "логин" и просит ввести его хэш в качестве секерта. Хеш счиатется как сумма юникод-кодов каждого символа, умноженная на 1 для четных позиций и на 2 для нечетных.
Код написан в двух вариантах, обфусцированном и необфусцированном, для сравнения.

# Пример правильных логина и секрета
Логин: `asd`
Секрет: `524`

# Список использзованных техник обфускации на этапе написания кода
Каждая из следующих техник видна в исходниках кода.

## GET запрос чере UNIX socket
Во время обработки происходит GET запрос к гитхабу. Программа использует при вычислении хеша его код возврата. Если запрос сделать не удается (например, нет интернета), то добавляется усложнение к следующему этапу ("карусели").

В зависимости от результата, в код добавляются несколько `nop;`-ов в виде asm-вставки. 

## Обфускация управления через "карусель" случайных функций
В коде есть десяток функций `epic_func_`, которые запускаются **в случайном порядке** до тех пор пока небудет получены результаты определенного списка функций. epic-функции запускаются специальной функцией по указателю. Это нужно чтобы не допустить оптимизаций, усложнить передачу управления и внести дополнительные зависимости между условиями запуска функций. Например, вместо одной может запуститься другая, или программа может не запускать одну из функций, пока не отработают еще две.

## Использование std::system для порождения дочернего процесса
Чтобы скрыть, какие именно результаты предыдущего шага используется, а так же породить дочерний процесс (и так еще усложнить передачу управления), в конце результат счиатется в зависимости от результата вызова `system("ls . > /dev/null")`. Обфускация написана в расчете, что на системе, где она будет запущена, будет и `ls` и  `/dev/null`.

## Непоследовательное хранение строк
Чтобы нельзя было легко при дизассемблировании увидеть (и понять бесполезность) сокета и `system`, строки адреса и команды храняться разбросанными по памяти в виде односвязного списка `std::list` и собираются в строку только перед вызовом функций.

# Дополнительные усложнения для анализа программы
Следующие усложнения могут также усложнить процесс реверса программы.

## Код следует компилировать без оптимизации
Это минимизирует вероятность того, что наши техники будут соптимизированы.
Например с помощью флага компиляции gcc `-O0`

## Бинарный файл должен быть очищен от символьной информации
Информация о символах не должна давать дополнительной ифнормации при анализе
Ее можно убрать при помощи утилиты UNIX `strip --strip-all`

## Код можно дополнительно запаковать
Например при помощи [upx](https://upx.github.io/)
